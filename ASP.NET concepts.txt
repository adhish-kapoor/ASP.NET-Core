// source: "https://www.tutorialspoint.com/asp.net_core/"

1. project.json file
=================
=> This file is using JavaScript object notation to store configuration information and it is this file that is really the heart of a .NET application. Without this file, you would not have an ASP.NET Core project.
Default code implementation in project.json file is as follows −
{
   "dependencies": {
      "Microsoft.NETCore.App": {
         "version": "1.0.0",
         "type": "platform"
      },
      "Microsoft.AspNetCore.Diagnostics": "1.0.0",
      "Microsoft.AspNetCore.Server.IISIntegration": "1.0.0",
      "Microsoft.AspNetCore.Server.Kestrel": "1.0.0",
      "Microsoft.Extensions.Logging.Console": "1.0.0"
   },
   "tools": {
      "Microsoft.AspNetCore.Server.IISIntegration.Tools": "1.0.0-preview2-final"
   },
   "frameworks": {
      "netcoreapp1.0": {
         "imports": ["dotnet5.6", "portable-net45+win8"]
      }
   },
   "buildOptions": {
      "emitEntryPoint": true,
      "preserveCompilationContext": true
   },
   "runtimeOptions": {
      "configProperties": {
         "System.GC.Server": true
      }
   },
   "publishOptions": {
      "include": ["wwwroot", "web.config" ]
   },
   "scripts": {
      "postpublish": [ "dotnet publish-iis --publish-folder %publish:OutputPath%
         --framework %publish:FullTargetFramework%" ]
   }
}


2. Startup.cs file
=================
=> There is a Startup class inside the file and in this class you can configure your application and even configure your configuration sources.
Default implementation in the Startup.cs file:

using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks; 

using Microsoft.AspNetCore.Builder; 
using Microsoft.AspNetCore.Hosting; 
using Microsoft.AspNetCore.Http; 

using Microsoft.Extensions.DependencyInjection; 
using Microsoft.Extensions.Logging;  

namespace FirstAppDemo { 
   public class Startup { 
      // This method gets called by the runtime.
      // Use this method to add services to the container. 
      // For more information on how to configure your application, 
      // visit http://go.microsoft.com/fwlink/?LinkID=398940 
      public void ConfigureServices(IServiceCollection services) { 
      }  
      
      // This method gets called by the runtime. Use this method to configure 
      // the HTTP request pipeline.
      public void Configure(IApplicationBuilder app, IHostingEnvironment env, 
         ILoggerFactory loggerFactory) { 
         loggerFactory.AddConsole();  
         
         if (env.IsDevelopment()) { 
            app.UseDeveloperExceptionPage(); 
         }  
         app.Run(async (context) => { 
            await context.Response.WriteAsync("Hello World!"); 
         }); 
      } 
   } 
}

The Configure method of the class is where you build your HTTP processing pipeline.
-This defines how your application responds to requests. 
-Currently this application can only say Hello World! and if we want the application to behave differently, we will need to change the pipeline around by adding additional code in this Configure method.
-ConfigureServices() method helps you configure components for your application.

-Right now, we have a hard-coded string for every response — the Hello World! string.
-Instead of hard-coding the string, we want to load this string from some component that knows the text that we want to display.
-Let us add the following code in AppSettings.json file.
{ 
   "message": "Hello, World! this message is from configuration file..." 
}

Startup.cs file which will read the above message from the JSON file:-

using Microsoft.AspNet.Builder; 
using Microsoft.AspNet.Hosting; 
using Microsoft.AspNet.Http; 

using Microsoft.Extensions.DependencyInjection; 
using Microsoft.Extensions.Configuration;  

namespace FirstAppDemo { 
   public class Startup { 
      public Startup() { 
         var builder = new ConfigurationBuilder()   
            .AddJsonFile("AppSettings.json"); 
         Configuration = builder.Build(); 
      }  
      public IConfiguration Configuration { get; set; }  
      
      // This method gets called by the runtime. 
      // Use this method to add services to the container. 
      // For more information on how to configure your application, 
      // visit http://go.microsoft.com/fwlink/?LinkID=398940 
      public void ConfigureServices(IServiceCollection services) { 
      }  
      
      // This method gets called by the runtime.  
      // Use this method to configure the HTTP request pipeline. 
      public void Configure(IApplicationBuilder app) {
         app.UseIISPlatformHandler();  
         app.Run(async (context) => { 
            var msg = Configuration["message"]; 
            await context.Response.WriteAsync(msg); 
         });  
      }  
        
      // Entry point for the application. 
      public static void Main(string[] args) =7gt; WebApplication.Run<Startup>(args); 
   } 
}


3. Middleware
==============
=> Middleware in ASP.NET Core controls how our application responds to HTTP requests.
-It can also control how our application looks when there is an error, and it is a key piece in how we authenticate and authorize a user to perform specific actions.
-Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.
-Each piece of middleware in ASP.NET Core is an object, and each piece has a very specific, focused, and limited role.
-Inside the Configure() method, we will invoke the extension methods on the IApplicationBuilder interface to add middleware.

There are two pieces of middleware in a new empty project by default −

I. IISPlatformHandler
II. Middleware registered with app.Run

I. IISPlatformHandler allows us to work with Windows authentication. 
It will look at every incoming request and see if there is any Windows identity information associated with that request and then it calls the next piece of middleware.

II. The next piece of middleware in this case is a piece of middleware registered with app.Run. 
The Run method allows us to pass in another method, which we can use to process every single response. 
Run is not something that you will see very often, it is something that we call a terminal piece of middleware.

Middleware that you register with Run will never have the opportunity to call another piece of middleware, all it does is receive a request, and then it has to produce some sort of response.
You also get access to a Response object and one of the things you can do with a Response object is to write a string.
If you want to register another piece of middleware after app.Run, that piece of middleware would never be called because, again, Run is a terminal piece of middleware. It will never call into the next piece of middleware.

-Microsoft.aspnet.diagnostics that is actually ASP.NET Core middleware for exception handling, exception display pages, and diagnostics information.

public void Configure(IApplicationBuilder app) { 
   app.UseIISPlatformHandler(); 
   app.UseWelcomePage();  
   
   app.Run(async (context) => { 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   });  
}

-Instead of using the Welcome page, we will use the RuntimeInfoPage.
public void Configure(IApplicationBuilder app) { 
   app.UseIISPlatformHandler(); 
   app.UseRuntimeInfoPage();  
   
   app.Run(async (context) => { 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   });  
}

This RuntimeInfoPage is a middleware that will only respond to requests that come in for a specific URL.
 If the incoming request does not match that URL, this piece of middleware just lets the request pass through to the next piece of middleware. 
The request will pass through the IISPlatformHandler middleware, then go to the UseRuntimeInfoPage middleware. 
It is not going to create a response, So it will go to our app.Run and display the string.


4. Exceptions and Error handling
===========================
=> Let us add another piece of middleware, which is the UseDeveloperExceptionPage.
public void Configure(IApplicationBuilder app) { 
   app.UseIISPlatformHandler();  
   app.UseDeveloperExceptionPage(); 
   app.UseRuntimeInfoPage();  
   
   app.Run(async (context) => { 
      throw new System.Exception("Throw Exception"); 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   });  
}

-This piece of middleware is a little bit different than the other pieces of middleware, the other pieces of middleware are typically looking at the incoming request and making some decision about that request.
-The UseDeveloperExceptionPage doesn't care so much about the incoming requests as it does what happens later in the pipeline.
-It is going to just call into the next piece of middleware, but then it is going to wait to see if anything later in the pipeline generates an exception and if there is an exception, this piece of middleware will give you an error page with some additional information about that exception.


5. Static files
==============
=> Static files like JavaScript files, images, CSS files that we have on the file system are the assets that ASP.NET Core application can serve directly to clients.
Static files are typically located in the web root (wwwroot) folder.
By default, that is the only place where we can serve up files directly from the file system.

-Microsoft.AspNet.StaticFiles which will find the static files middleware. 
Let us install this nuget package and now we should have additional methods that we can use to register middleware inside the Configure method.

UseStaticFiles middle in Configure method as shown in the following program:

 public void Configure(IApplicationBuilder app) { 
         app.UseIISPlatformHandler();  
         app.UseDeveloperExceptionPage(); 
         app.UseRuntimeInfoPage(); 
         app.UseStaticFiles(); 
         
         app.Run(async (context) => { 
            throw new System.Exception("Throw Exception"); 
            var msg = Configuration["message"]; 
            await context.Response.WriteAsync(msg); 
         }); 
      }  

-You can always give IIS a list of default files to look for. If someone came to the root of a directory or, in this case, the root of the website and if IIS found something named index.html, it would just automatically serve that file.
Let us now start by making a few changes. First, we need to remove the forced error and then add another piece of middleware, which is UseDefaultFiles. 
The following is the implementation of the Configure method:

public void Configure(IApplicationBuilder app)  { 
   app.UseIISPlatformHandler();  
   app.UseDeveloperExceptionPage(); 
   
   app.UseRuntimeInfoPage();  
   app.UseDefaultFiles(); 
   app.UseStaticFiles();  
   
   app.Run(async (context) => { 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   });  
}

-If you are going to use UseDefaultFiles and UseStaticFiles, you might also want another piece of middleware that is inside the Microsoft.aspnet.staticfiles, NuGet package, and that is the FileServer middleware. 
This essentially includes the Default Files and the Static Files in the correct order.

public void Configure(IApplicationBuilder app) { 
   app.UseIISPlatformHandler();  
   app.UseDeveloperExceptionPage(); 
   
   app.UseRuntimeInfoPage();  
   app.UseFileServer();  
   
   app.Run(async (context) => { 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   }); 
}


6. Setup MVC framework in ASP.NET Core
========================================
=> To setup MVC framework in our empty project, follow these steps −

Install the Microsoft.AspNet.Mvc package, which gives us access to the assemblies and classes provided by the framework.

Once the package is installed, we need to register all of the services that ASP.NET MVC requires at runtime. We will do this inside the ConfigureServices method.

Finally, we need to add middleware for ASP.NET MVC to receive requests. Essentially this piece of middleware takes an HTTP request and tries to direct that request to a C# class that we will write.

-Adding HomeController.cs in our project:
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppdemo.Controllers { 
   public class HomeController { 
      public string Index() { 
         return "Hello, World! this message is from Home Controller..."; 
      } 
   } 
}

-In addition to adding the NuGet package and the middleware, we also need to add the AddMvc service in the ConfigureServices.
 Here is the complete implementation of the Startup class:-

using Microsoft.AspNet.Builder; 
using Microsoft.AspNet.Hosting; 
using Microsoft.AspNet.Http; 

using Microsoft.Extensions.DependencyInjection; 
using Microsoft.Extensions.Configuration;  

namespace FirstAppDemo { 
   public class Startup { 
      public Startup() { 
         var builder = new ConfigurationBuilder() .AddJsonFile("AppSettings.json"); 
         Configuration = builder.Build(); 
      }  
      public IConfiguration Configuration { get; set; }
      
      // This method gets called by the runtime. 
      // Use this method to add services to the container. 
      // For more information on how to configure your application, 
      // visit http://go.microsoft.com/fwlink/?LinkID=398940 
      public void ConfigureServices(IServiceCollection services) { 
         services.AddMvc(); 
      }
      
      // This method gets called by the runtime.  
      // Use this method to configure the HTTP request pipeline. 
      public void Configure(IApplicationBuilder app) { 
         app.UseIISPlatformHandler();  
         
         app.UseDeveloperExceptionPage(); 
         app.UseRuntimeInfoPage();  
         
         app.UseFileServer(); 
         app.UseMvcWithDefaultRoute();  
         
         app.Run(async (context) => { 
            var msg = Configuration["message"]; 
            await context.Response.WriteAsync(msg); 
         });
      } 
      
      // Entry point for the application. 
      public static void Main(string[] args) => WebApplication.Run<Startup>(args); 
   }  
}
   
-Save the Startup.cs file and go to the browser and refresh it. You will now receive a response from our home controller


7. Routing
============
=> Routing is the process of directing an HTTP request to a controller.
-The ASP.NET Core middleware needs a way to determine if a given HTTP request should go to a controller for processing or not.

The MVC middleware will make this decision based on the URL and some configuration information we provide. 
In this chapter, we will define this configuration information or you can say routing information inside Startup.cs when we add the MVC middleware.

This approach is often referred to as the convention-based routing. 
The following is a code snippet for conventional routing.

                    routeBuilder.MapRoute("Default", "{controller=Home}/{action=Index}/{id?}");

In this approach, we define templates that tell MVC how to look at a URL and find a controller name and an action name where a controller is a C# class and an action is a public method on that class.

-Instead of using the UseMvcWithDefaultRoute, let us use the UseMvc, and then configure the route at this point using a named method ConfigureRoute. 
The following is the implementation of the Startup.cs file:-

using Microsoft.AspNet.Builder; 
using Microsoft.AspNet.Hosting; 
using Microsoft.AspNet.Http; 

using Microsoft.Extensions.DependencyInjection; 
using Microsoft.Extensions.Configuration; 
using Microsoft.AspNet.Routing; 
using System;  

namespace FirstAppDemo { 
   public class Startup { 
      public Startup() { 
         var builder = new ConfigurationBuilder() .AddJsonFile("AppSettings.json"); 
         Configuration = builder.Build(); 
      }  
      public IConfiguration Configuration { get; set; } 
      
      // This method gets called by the runtime. 
      // Use this method to add services to the container. 
      // For more information on how to configure your application, 
      // visit http://go.microsoft.com/fwlink/?LinkID=398940 
      public void ConfigureServices(IServiceCollection services) { 
         services.AddMvc(); 
      }  
        
      // This method gets called by the runtime.  
      // Use this method to configure the HTTP request pipeline. 
      public void Configure(IApplicationBuilder app) { 
         app.UseIISPlatformHandler();  
         
         app.UseDeveloperExceptionPage(); 
         app.UseRuntimeInfoPage();  
         
         app.UseFileServer(); 
         app.UseMvc(ConfigureRoute);  
         
         app.Run(async (context) => { 
            var msg = Configuration["message"]; 
            await context.Response.WriteAsync(msg); 
         });
      }  
      private void ConfigureRoute(IRouteBuilder routeBuilder) { 
         //Home/Index 
         routeBuilder.MapRoute("Default", "{controller = Home}/{action = Index}/{id?}");
      }  
        
      // Entry point for the application. 
      public static void Main(string[] args) => WebApplication.Run<Startup>(args);
   } 
}

-Inside the ConfigureRoute method, you can configure your routes; you can see that this method has to take a parameter of type IRouteBuilder. 
The goal of routing is to describe the rules that ASP.NET Core MVC will use to process an HTTP request and find a controller that can respond to that request.

-You can have one route that can map requests to different controllers.

-We can tell the routeBuilder that we want to map a new route and its name is “Default” and then provide the most important piece of routing information, which is the template.

-The template is a string, and it is going to describe to ASP.NET Core MVC how to pull apart a URL.

-In the last example, we have added a HomeController, so you can also request any of the following URLs, and they will be directed to the Index action on the HomeController as well.

		http://localhost:49940
               	 	http://localhost:49940/Home
 		http://localhost:49940/Home/Index
-When a browser requests http://mysite/or http://mysite/Home, it gets back the output from the HomeController’s Index method.

-You can try this as well by changing the URL in the browser. In this example, it is http://localhost:49940/, except that the port which might be different.

-If you append /Home or /Home/Index to the URL and press the Enter button, you will see the same result.

==>Let us create another controller by adding another class and call it AboutController.
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppDemo.Controllers  { 
   public class AboutController { 
      public string Phone() { 
         return "+49-333-3333333"; 
      }  
      public string Country() { 
         return "Germany"; 
      } 
   } 
} 

-If you go to /about, it is again going to fall through the middleware and go to your app.Run middleware and you will see the page with output:
Here, the ASP.NET Core MVC goes to the AboutController, but does not find an action specified. 
So it will default to Index and this controller doesn't have an Index method and then the request will go the next piece of middleware.


8. Attribute Routes
===================
=> With attribute-based routing, we can use C# attributes on our controller classes and on the methods internally in these classes. 
These attributes have metadata that tell ASP.NET Core when to call a specific controller.

-It is an alternative to convention-based routing.

-Routes are evaluated in the order that they appear, the order that you register them in, but it's quite common to map multiple routes particularly if you want to have different parameters in the URL or if you want to have different literals in the URL.

-What we want here is that when we specify /about, the application should invoke the Phone action of the AboutController. 
Here, we can enforce some explicit routes for this controller using a Route attribute. This attribute is in the namespace Microsoft.AspNet.Mvc.
The following is the implementation of AboutController in which the attribute routes are added:-

using Microsoft.AspNet.Mvc;  

using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppDemo.Controllers { 
   [Route("about")] 
   public class AboutController { 
      [Route ("")] 
      public string Phone() { 
         return "+49-333-3333333"; 
      }  
      [Route("country")] 
      public string Country() { 
         return "Germany"; 
      } 
   } 
}


9. Action Results
=================
=> Actions basically return different types of Action Results. The ActionResult class is the base for all the action results. 
The following is a list of different kind of action results and their behavior.

		Name	                	Behavior
	=======================================================
		ContentResult		        Returns a string
		FileContentResult		Returns file content
		FilePathResult			Returns file content
		FileStreamResult		Returns file content.
		EmptyResult			Returns nothing
		JavaScriptResult		Returns script for execution
		JsonResult			Returns JSON formatted data
		RedirectToResult		Redirects to the specified URL
		HttpUnauthorizedResult		Returns 403 HTTP Status code
		RedirectToRouteResult		Redirect to different action/ different controller action
		ViewResult			Received as a response for view engine
		PartialViewResult		Received as a response for view engine

Example 1
Let us perform a simple example by opening the HomeController class and derive it from the controller based class. This base class is in the Microsoft.AspNet.Mvc namespace. 
The following is the implementation of the HomeController class.

using Microsoft.AspNet.Mvc; 
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppdemo.Controllers  { 
   public class HomeController : Controller { 
      public ContentResult Index() { 
         return Content("Hello, World! this message is from 
            Home Controller using the Action Result"); 
      } 
   } 
}

In the Index method, we have passed a string into the Content method. This Content method produces a ContentResult; this means the Index method will now return ContentResult.

Example 2
Let us take another example. Create a new folder in the project and call it Models. Inside the Models folder, we want to add a class that can represent an Employee.
Enter Employee.cs in the Name field. 
Here, the implementation of the Employee class contains two properties:-

using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppDemo.Models { 
   public class Employee { 
      public int ID { get; set; } 
      public string Name { get; set} 
   } 
}

Inside the Index action method of HomeController, we want to return an Employee object. 
The following is the implementation of HomeController:-

using FirstAppDemo.Models; 
using Microsoft.AspNet.Mvc; 

using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppdemo.Controllers { 
   public class HomeController : Controller { 
      public ObjectResult Index() { 
         var employee = new Employee { ID = 1, Name = "Mark Upston"}; 
         return new ObjectResult(employee);                                                                                                             // output in browser:- {"ID":1, "Name":"Mark Upston"}
      } 
   } 
}

Now, instead of returning the Content, we will return a different type of result which is known as ObjectResult. 
If we want an ObjectResult, we need to create or instantiate an ObjectResult and pass into it some model object.

-An ObjectResult is special in the MVC framework because when we return an ObjectResult, the MVC framework looks at this object. 
This object needs to be represented in the HTTP response.

-This object should be serialized into XML or JSON or some other format and ultimately, the decision will be made based on the configuration information that you give to the MVC at startup. 
If you don't configure anything, you just get some defaults, and the default is a JSON response.


10. Views
=============
=> A controller action might return a view or it might also perform some other type of action such as redirecting to another controller action.
-With the MVC framework, the most popular method for creating HTML is to use the Razor view engine of ASP.NET MVC.

-To use this view engine, a controller action produces a ViewResult object, and a ViewResult can carry the name of the Razor view that we want to use.
-The view will be a file on the file system and the ViewResult can also carry along a model object to the view and the view can use this model object when it creates the HTML.

-When the MVC framework sees that your controller action produces a ViewResult, the framework will find the view on the file system, execute the view, which produces HTML, and it is this HTML which the framework sends back to the client.

-Views by default in a C# ASP.NET project are files that have a *.cshtml extension and the views follow a specific convention. By default, all views live in a Views folder in the project.
-It will go into a Home folder and then look for a file called Index.cshtml − the file name starts with Index because we are in the Index action.
-The MVC framework will also look in a Shared folder and views that you place inside the Shared folder, you can use them anywhere in the application.

-This View method has a couple of different overloads, and pass the employee model as parameter:

using FirstAppDemo.Models; 
using Microsoft.AspNet.Mvc; 

using System; 
using System.Collections.Generic; 
using System.Linq;
using System.Threading.Tasks;  

namespace FirstAppdemo.Controllers { 
   public class HomeController : Controller { 
      public ViewResult Index() { 
         var employee = new Employee { ID = 1, Name = "Mark Upston"}; 
         return View(employee); 
      } 
   } 
} 

-The View method that just takes a model object and that will use the default view, which is Index. 
Here we just want to pass in that model information and use that model inside Index.cshtml as shown in the following program.

<html xmlns = "http://www.w3.org/1999/xhtml"> 
   <head> 
      <title>Home</title> 
   </head> 
   
   <body> 
      <h1>Welcome!</h1> 
      
      <div>                                                                                                                                                   // output in browser:-
         @Model.Name                                                                                                                                 // Welcome!
      </div>                                                                                                                                                 // Mark Upston
   </body> 
</html>

Razor view contains some built-in members that we can access inside the C# expressions. One of the most important members is the Model.
When you say @Model, then you will get the model object that you have passed into the view from the controller. 
So here the @Model.Name will display the employee name inside the view.


11. Setting EF
================
=> Install Entity Framework
The first step in using the Entity Framework is to install the Entity Framework NuGet package from the NuGet package manager or by editing the project.json file directly.
-Edit project.json by adding the following two packages:
                         1. The EntityFramework.Commands package helps us perform tasks with the Entity Framework like creating a database schema based on our C# Entity classes and these tasks are available from a command line tool where the logic lives inside the EntityFramework.Commands package.
                         2. The EntityFramework.MicrosoftSqlServer
-In order to use this command line tool, we need to make an additional entry into the commands section of project.json:
-We have just called it “ef” and that will map to this EntityFramework.Commands package. 
-We can use this “ef” to get access to some of the logic that is available inside EntityFramework.Commands.

The following is the implementation of the project.json file:

{ 
   "version": "1.0.0-*", 
   "compilationOptions": { 
      "emitEntryPoint": true 
   },  
   
   "dependencies": { 
      "Microsoft.AspNet.Mvc": "6.0.0-rc1-final", 
      "Microsoft.AspNet.Diagnostics": "1.0.0-rc1-final", 
      "Microsoft.AspNet.IISPlatformHandler": "1.0.0-rc1-final", 
      "Microsoft.AspNet.Server.Kestrel": "1.0.0-rc1-final", 
      "Microsoft.AspNet.StaticFiles": "1.0.0-rc1-final", 
      "EntityFramework.MicrosoftSqlServer": "7.0.0-rc1-final", 
      "EntityFramework.Commands": "7.0.0-rc1-final" 
   }
   
   "commands": { 
      "web": "Microsoft.AspNet.Server.Kestrel" 
   },  
  
   "frameworks": { 
      "dnx451": { }, 
      "dnxcore50": { } 
   },  
  
   "exclude": [ 
      "wwwroot", 
      "node_modules" 
   ], 
  
   "publishExclude": [ 
      "**.user", 
      "**.vspscc" 
   ] 
}


12. DBContext
=================
=> The Entity Framework enables you to query, insert, update, and delete data, using Common Language Runtime (CLR) objects known as entities. 
     The Entity Framework maps the entities and relationships that are defined in your model to a database. It also provides facilities to −

		1. Materialize data returned from the database as entity objects.

		2. Track changes that were made to the objects.

		3. Handle concurrency.

		4. Propagate object changes back to the database.

		5. Bind objects to controls.

-The primary class that is responsible for interacting with data as objects is the DbContext. 
-Logically, a DBContext maps to a specific database that has a schema that the DBContext understands. And on that DBContext class, you can create properties that are type DbSet<T>. 
-The generic type parameter T will be a type of entity like Employee is an entity in the FirstAppDemo application.

-Here, we need to add a new class in Models folder and call it FirstAppDempDbContext. Even though this class is not a model in itself, it does put together all our Models so that we can use them with the database.
-Inherit your context class from the DbContext class which is in Miscrosoft.Data.Entity namespace. 
-Now implement a DbSet of Employee on that class.

-Each DbSet will map to a table in the database. If you have a property DbSet of employee, and the name of that property is Employees, the Entity Framework will by default look for an Employees table inside your database.

using FirstAppDemo.Models; 
using Microsoft.Data.Entity; 

using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace OdeToFood.Models { 
   public class FirstAppDemoDbContext : DbContext { 
      public DbSet<Employee> Employees { get; set; } 
   } 
} 

- Let us now insert this class directly into controllers, and the controllers could then use FirstAppDemoDbContext to query the database. 
We will simplify all these by adding a new class to the HomeController class in which we implement methods to Add employee and Get employee as shown in the following program.

using Microsoft.AspNet.Mvc; 

using FirstAppDemo.ViewModels; 
using FirstAppDemo.Services; 
using FirstAppDemo.Entities; 
using FirstAppDemo.Models; 

using System.Collections.Generic; 
using System.Linq;  

namespace FirstAppDemo.Controllers { 
   public class HomeController : Controller { 
      public ViewResult Index() { 
         var model = new HomePageViewModel(); 
         
         using (var context = new FirstAppDemoDbContext()) { 
            SQLEmployeeData sqlData = new SQLEmployeeData(context); 
               model.Employees = sqlData.GetAll(); 
         }  
         return View(model); 
      } 
   }  
   public class SQLEmployeeData { 
      private FirstAppDemoDbContext _context { get; set; } 
      public SQLEmployeeData(FirstAppDemoDbContext context) { 
         _context = context;
      } 
      public void Add(Employee emp) { 
         _context.Add(emp); 
         _context.SaveChanges(); 
      } 
      public Employee Get(int ID) { 
         return _context.Employees.FirstOrDefault(e => e.Id == ID); 
      } 
      public IEnumerable<Employee> GetAll() { 
         return _context.Employees.ToList<Employee>(); 
      } 
   } 
   public class HomePageViewModel { 
      public IEnumerable<Employee> Employees { get; set; } 
   } 
}  

- In the above SQLEmployeeData class, you can see that we have defined the Add method which will add a new employee object to the context and then it will save the changes. 
- In the Get method, it will return an employee based on the ID. Whereas, in the GetAll method it will return the list of all the employees in the database.

****Configuring the Entity Framework Services****
****				   ****
To have a usable Entity Framework DBContext, we need to change the configuration of the application. We will need to add a connection string so that our DBContext knows which server to go to and which database to query.

1. We will put the connection string in a JSON configuration file.

2. We also need to add some more services during the ConfigureServices method of the Startup class.

3. The Entity Framework, just like ASP.NET and the MVC framework, the Entity Framework relies on dependency injection, and for injection to work, the runtime needs to know about the various services that the Entity Framework uses.

4. There is an easy configuration API that will add all the default services that we need.

=> AppSettings.json file and add the connections string as shown in the following program.

{ 
   "message": "Hello, World! this message is from configuration file...", 
   "database": { 
      "connection": "Data Source=(localdb)\\mssqllocaldb;Initial Catalog=FirstAppDemo" 
   } 
}

=> Startup class where we need to add some additional services for the Entity Framework to work properly. Specifically, there are three things that we need to do that are related to the Entity Framework −

		1. We need to add the core Entity Framework services.

		2. We also need to add the SQL Server-related Entity Framework services.

		3. We need to tell the Entity Framework about our DBContext.

All this can be done through methods that are available as extension methods on IServiceCollection as shown in the following program.

public void ConfigureServices(IServiceCollection services) { 
   services.AddMvc(); 
   services.AddEntityFramework() 
      .AddSqlServer() 
      .AddDbContext<FirstAppDemoDbContext>
   
   (option => option.UseSqlServer(Configuration["database:connection"])); 
} 

		4. The first method is the AddEntityFramework. This will add the core Entity Framework services, the default services.

		5. But since the Entity Framework is now designed to work with different sorts of databases, including non-relational databases, we need to make a second call to tell the Entity Framework to add its default SQL Server-related services.

		6. Then we also need to tell the Entity Framework about my DBContext class so it can construct instances of that class appropriately and we can do that through a third method, the AddDbContext method.

		7. This one takes a generic type parameter where we specify the type of the DBContext derived class, the FirstAppDemoDbContext.

		8. Inside the AddDbContext, we need to describe the options for our DBContext.

		9. This can be done by a lambda expression; it is an action where we receive an option parameter and the Entity Framework can support the different databases. All we need to do is, tell the Entity Framework that this particular DBContext is going to UseSqlServer.

		10. This method requires a parameter which is the connectionString to use.

The following is the complete implementation of the Startup.cs file.

using Microsoft.AspNet.Mvc; 
using FirstAppDemo.ViewModels; 
using FirstAppDemo.Services; 
using FirstAppDemo.Entities; 
using FirstAppDemo.Models; 

using System.Collections.Generic; 
using System.Linq;  

namespace FirstAppDemo.Controllers { 
   public class HomeController : Controller { 
      public ViewResult Index() { 
         var employee = new Employee { Id = 1, Name = "Mark Upston1" }; 
         using (var context = new 
         
         FirstAppDemoDbContext()) { 
            SQLEmployeeData sqlData = new SQLEmployeeData(context); 
            sqlData.Add(employee); 
         } 
         
         //var employee = new Employee { ID = 1, Name = "Mark Upston" }; 
         return View(employee); 
      } 
   }  
   public class SQLEmployeeData { 
      private FirstAppDemoDbContext _context { get; set; }  
      public SQLEmployeeData(FirstAppDemoDbContext context) { 
         _context = context; 
      }  
      public void Add(Employee emp) { 
         _context.Add(emp); 
         _context.SaveChanges(); 
      } 
      public Employee Get(int ID) { 
         return _context.Employees.FirstOrDefault(e => e.Id == ID); 
      } 
      public IEnumerable<Employee> GetAll() { 
         return _context.Employees.ToList<Employee>(); 
      } 
   } 
} 

Now we need to set up the database.
One way to get a database set up is to use the Entity Framework to create the database and this is a two-step process −

***The First Step***

		1. Adding migration code to our project.

		2. The migration code is C# code. This can be executed to create a database in a database schema.

		3. The Entity Framework can generate this migration code for us.

		4. The Entity Framework looks at the database and at our models and figures out what the schema changes are required to make the application work.

		5. So when we add additional models or make changes to the existing models, like the Employee class, we can continue to add migrations to our project and keep our database schema in sync.

***The Second Step***

		1. Here, we need to explicitly apply those migrations to update a database.

		2. Both of these tasks can be achieved by using some easy commands from a console window.

		3. We have made project.json.

		4. That is why we have made project.json to add a command where “ef” maps to EntityFramework.Commands.

 ---Let us open the Developer Command Prompt for Visual Studio to run the commands that we need to add the migrations and apply the migrations. The easiest way to do this is to go to the application root directory.
- If you are in the folder that has the project.json file, then you are in the correct folder.
1. Here, we need to execute a command known as dnvm. This is the .NET version manager which will tell the system what runtime we want to use.

Let us now use the following command.

dnvm list 

2. We need to tell the dnvm that we want to use the specific runtimes. This will give us access to the dotnet command or the dnx command that we want to execute.

Execute the following command.

dnvm use1.0.0-rc1-update1 -p

3. dnvm will set up our path and the environment variables to include a bin directory that will give us access to this dnx utility. 
Let us execute the dnx ef command.

This is the .NET execution environment, using dnx, we can call the commands that we have listed in our project.json file.
 Executing these commands is generally very easy. 
When you type dnx ef, you will get a help screen. You don't have to remember all the options. 
You can see the available commands from the Entity Framework Commands and there are three of them.

First, we need to add migration to execute the following command.

dnx ef migrations add v1

The Entity Framework will find that context and look at the models that are inside. 
It will know that there is no previous migration and so it is going to generate the first migration. 
Here, v1 is the version 1 of the database. It will create a new folder in Solution Explorer and generate code.

A migration is essentially a C# code that is used to generate SQL commands to modify the schema in a SQL database.

using System; 
using System.Collections.Generic; 

using Microsoft.Data.Entity.Migrations; 
using Microsoft.Data.Entity.Metadata;  

namespace FirstAppDemo.Migrations { 
   public partial class v1 : Migration { 
      protected override void Up(MigrationBuilder migrationBuilder) { 
         
         migrationBuilder.CreateTable(name: "Employee", columns: table => new { 
            Id = table.Column<int>(nullable: false)    
               .Annotation("SqlServer:ValueGenerationStrategy",
               SqlServerValueGenerationStrategy.IdentityColumn),                        
               Name = table.Column<string>(nullable: true) 
         }, 
         constraints: table => { 
            table.PrimaryKey("PK_Employee", x => x.Id); 
         }); 
      }  
      protected override void Down(MigrationBuilder migrationBuilder) { 
         migrationBuilder.DropTable("Employee"); 
      } 
   } 
}

You can see it will create a table called Employees.

		1. This table should have two columns — an ID, and a Name column.

		2. By convention, when the Entity Framework sees that you have a property called Id, it will make that property or, rather, make that column a primary key in the database.

		3. Here, we will use the SQL Server. By default, the Entity Framework will make that an IdentityColumn, which means the SQL Server will generate the IDs for us.

- Let us apply these IDs to a database by typing the “dnx ef database update” command.
You can see that the command has applied migration.

- Let us now go to the SQL Server Object Explorer, and refresh the databases, you can now see we have a FirstAppDemo database.

You can also see our Employee table and we can even look at the columns for that table in which the ID column is the primary key.
Let us right-click on the dbo.Employee table and select View Data.

Before we run the application, let us add some data. When we launch the application, we should see some data from the database. 
Let us just add a couple of rows of data here.									
				Id	Name
				1	Adhish
				2	Adi
				3	AK

- Let us now update the index.cshtml file. It shows all the data in tabular form

@model FirstAppDemo.Controllers.HomePageViewModel 
<html xmlns="http://www.w3.org/1999/xhtml"> 
   <head> 
       <title>Home</title> 
   </head> 

   <body> 
      <h1>Welcome!</h1> 
      
      <table> 
         @foreach (var employee in Model.Employees) { 
            <tr> 
               <td>   
                  @Html.ActionLink(employee.Id.ToString(), "Details", new 							1	Adhish
													2	Adi
													3	AK
                     { id = employee.Id }) 
               </td> 
               <td>@employee.Name</td> 
            </tr> 
         } 
      </table> 
   </body> 
</html>


13. Razor Layout Views
========================
=> Layout View

1. A Layout view is a Razor view with a *.cshtml extension. 
You have a choice to name a Layout view the way you want.

2. This is a common name for a Layout view, and the leading underscore is not required.
That is just a convention that many developers follow to identify a view that is not a view; you render this as a view result from a controller action.

3. It is a special kind of view, but once we have a Layout view, we can set up our controller views like the Index view for the home page.
						
4. We can set up this view to render inside the Layout view at a specific location.

5. This Layout view approach means that the Index.cshtml doesn't need to know anything about the logo or the top level navigation.

6. The Index view only needs to render the specific content for the model the controller action gives this view and the Layout view takes care of everything else.


14. Host
================
On startup, an ASP.NET Core app builds a host. The host encapsulates all of the app's resources, such as:

1. An HTTP server implementation
2. Middleware components
3. Logging
4. Dependency injection (DI) services
5. Configuration

There are two different hosts:
1. .NET Generic Host
2. ASP.NET Core Web Host

The .NET Generic Host is recommended. 
The ASP.NET Core Web Host is available only for backwards compatibility.

The following example creates a .NET Generic Host:
public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });
}

The CreateDefaultBuilder and ConfigureWebHostDefaults methods configure a host with a set of default options, such as:

1. Use Kestrel as the web server and enable IIS integration.
2. Load configuration from appsettings.json, appsettings.{Environment Name}.json, environment variables, command line arguments, and other configuration sources.
3. Send logging output to the console and debug providers.


15. Servers
===============
An ASP.NET Core app uses an HTTP server implementation to listen for HTTP requests. The server surfaces requests to the app as a set of request features composed into an HttpContext.

ASP.NET Core provides the following server implementations:

1. Kestrel is a cross-platform web server. Kestrel is often run in a reverse proxy configuration using IIS. 
In ASP.NET Core 2.0 or later, Kestrel can be run as a public-facing edge server exposed directly to the Internet.
2. IIS HTTP Server is a server for Windows that uses IIS. With this server, the ASP.NET Core app and IIS run in the same process.
3. HTTP.sys is a server for Windows that isn't used with IIS.


16. Content root
====================
The content root is the base path for:

1. The executable hosting the app (.exe).
2. Compiled assemblies that make up the app (.dll).
3. Content files used by the app, such as:
	Razor files (.cshtml, .razor)
	Configuration files (.json, .xml)
	Data files (.db)
4. The Web root, typically the wwwroot folder.

During development, the content root defaults to the project's root directory. This directory is also the base path for both the app's content files and the Web root. 


17. Web root
====================
The web root is the base path for public, static resource files, such as:

1. Stylesheets (.css)
2. JavaScript (.js)
3. Images (.png, .jpg)
By default, static files are served only from the web root directory and its sub-directories. The web root path defaults to {content root}/wwwroot.

Prevent publishing files in wwwroot with the <Content> project item in the project file. 
The following example prevents publishing content in wwwroot/local and its sub-directories:
<ItemGroup>
  <Content Update="wwwroot\local\**\*.*" CopyToPublishDirectory="Never" />
</ItemGroup>

In Razor .cshtml files, tilde-slash (~/) points to the web root. A path beginning with ~/ is referred to as a virtual path.


