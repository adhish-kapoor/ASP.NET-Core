// source: "https://www.tutorialspoint.com/asp.net_core/"

1. project.json file
=================
=> This file is using JavaScript object notation to store configuration information and it is this file that is really the heart of a .NET application. Without this file, you would not have an ASP.NET Core project.
Default code implementation in project.json file is as follows −
{
   "dependencies": {
      "Microsoft.NETCore.App": {
         "version": "1.0.0",
         "type": "platform"
      },
      "Microsoft.AspNetCore.Diagnostics": "1.0.0",
      "Microsoft.AspNetCore.Server.IISIntegration": "1.0.0",
      "Microsoft.AspNetCore.Server.Kestrel": "1.0.0",
      "Microsoft.Extensions.Logging.Console": "1.0.0"
   },
   "tools": {
      "Microsoft.AspNetCore.Server.IISIntegration.Tools": "1.0.0-preview2-final"
   },
   "frameworks": {
      "netcoreapp1.0": {
         "imports": ["dotnet5.6", "portable-net45+win8"]
      }
   },
   "buildOptions": {
      "emitEntryPoint": true,
      "preserveCompilationContext": true
   },
   "runtimeOptions": {
      "configProperties": {
         "System.GC.Server": true
      }
   },
   "publishOptions": {
      "include": ["wwwroot", "web.config" ]
   },
   "scripts": {
      "postpublish": [ "dotnet publish-iis --publish-folder %publish:OutputPath%
         --framework %publish:FullTargetFramework%" ]
   }
}


2. Startup.cs file
=================
=> There is a Startup class inside the file and in this class you can configure your application and even configure your configuration sources.
Default implementation in the Startup.cs file:

using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks; 

using Microsoft.AspNetCore.Builder; 
using Microsoft.AspNetCore.Hosting; 
using Microsoft.AspNetCore.Http; 

using Microsoft.Extensions.DependencyInjection; 
using Microsoft.Extensions.Logging;  

namespace FirstAppDemo { 
   public class Startup { 
      // This method gets called by the runtime.
      // Use this method to add services to the container. 
      // For more information on how to configure your application, 
      // visit http://go.microsoft.com/fwlink/?LinkID=398940 
      public void ConfigureServices(IServiceCollection services) { 
      }  
      
      // This method gets called by the runtime. Use this method to configure 
      // the HTTP request pipeline.
      public void Configure(IApplicationBuilder app, IHostingEnvironment env, 
         ILoggerFactory loggerFactory) { 
         loggerFactory.AddConsole();  
         
         if (env.IsDevelopment()) { 
            app.UseDeveloperExceptionPage(); 
         }  
         app.Run(async (context) => { 
            await context.Response.WriteAsync("Hello World!"); 
         }); 
      } 
   } 
}

The Configure method of the class is where you build your HTTP processing pipeline.
-This defines how your application responds to requests. 
-Currently this application can only say Hello World! and if we want the application to behave differently, we will need to change the pipeline around by adding additional code in this Configure method.
-ConfigureServices() method helps you configure components for your application.

-Right now, we have a hard-coded string for every response — the Hello World! string.
-Instead of hard-coding the string, we want to load this string from some component that knows the text that we want to display.
-Let us add the following code in AppSettings.json file.
{ 
   "message": "Hello, World! this message is from configuration file..." 
}

Startup.cs file which will read the above message from the JSON file:-

using Microsoft.AspNet.Builder; 
using Microsoft.AspNet.Hosting; 
using Microsoft.AspNet.Http; 

using Microsoft.Extensions.DependencyInjection; 
using Microsoft.Extensions.Configuration;  

namespace FirstAppDemo { 
   public class Startup { 
      public Startup() { 
         var builder = new ConfigurationBuilder()   
            .AddJsonFile("AppSettings.json"); 
         Configuration = builder.Build(); 
      }  
      public IConfiguration Configuration { get; set; }  
      
      // This method gets called by the runtime. 
      // Use this method to add services to the container. 
      // For more information on how to configure your application, 
      // visit http://go.microsoft.com/fwlink/?LinkID=398940 
      public void ConfigureServices(IServiceCollection services) { 
      }  
      
      // This method gets called by the runtime.  
      // Use this method to configure the HTTP request pipeline. 
      public void Configure(IApplicationBuilder app) {
         app.UseIISPlatformHandler();  
         app.Run(async (context) => { 
            var msg = Configuration["message"]; 
            await context.Response.WriteAsync(msg); 
         });  
      }  
        
      // Entry point for the application. 
      public static void Main(string[] args) =7gt; WebApplication.Run<Startup>(args); 
   } 
}


3. Middleware
==============
=> Middleware in ASP.NET Core controls how our application responds to HTTP requests.
-It can also control how our application looks when there is an error, and it is a key piece in how we authenticate and authorize a user to perform specific actions.
-Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.
-Each piece of middleware in ASP.NET Core is an object, and each piece has a very specific, focused, and limited role.
-Inside the Configure() method, we will invoke the extension methods on the IApplicationBuilder interface to add middleware.

There are two pieces of middleware in a new empty project by default −

I. IISPlatformHandler
II. Middleware registered with app.Run

I. IISPlatformHandler allows us to work with Windows authentication. 
It will look at every incoming request and see if there is any Windows identity information associated with that request and then it calls the next piece of middleware.

II. The next piece of middleware in this case is a piece of middleware registered with app.Run. 
The Run method allows us to pass in another method, which we can use to process every single response. 
Run is not something that you will see very often, it is something that we call a terminal piece of middleware.

Middleware that you register with Run will never have the opportunity to call another piece of middleware, all it does is receive a request, and then it has to produce some sort of response.
You also get access to a Response object and one of the things you can do with a Response object is to write a string.
If you want to register another piece of middleware after app.Run, that piece of middleware would never be called because, again, Run is a terminal piece of middleware. It will never call into the next piece of middleware.

-Microsoft.aspnet.diagnostics that is actually ASP.NET Core middleware for exception handling, exception display pages, and diagnostics information.

public void Configure(IApplicationBuilder app) { 
   app.UseIISPlatformHandler(); 
   app.UseWelcomePage();  
   
   app.Run(async (context) => { 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   });  
}

-Instead of using the Welcome page, we will use the RuntimeInfoPage.
public void Configure(IApplicationBuilder app) { 
   app.UseIISPlatformHandler(); 
   app.UseRuntimeInfoPage();  
   
   app.Run(async (context) => { 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   });  
}

This RuntimeInfoPage is a middleware that will only respond to requests that come in for a specific URL.
 If the incoming request does not match that URL, this piece of middleware just lets the request pass through to the next piece of middleware. 
The request will pass through the IISPlatformHandler middleware, then go to the UseRuntimeInfoPage middleware. 
It is not going to create a response, So it will go to our app.Run and display the string.


4. Exceptions and Error handling
===========================
=> Let us add another piece of middleware, which is the UseDeveloperExceptionPage.
public void Configure(IApplicationBuilder app) { 
   app.UseIISPlatformHandler();  
   app.UseDeveloperExceptionPage(); 
   app.UseRuntimeInfoPage();  
   
   app.Run(async (context) => { 
      throw new System.Exception("Throw Exception"); 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   });  
}

-This piece of middleware is a little bit different than the other pieces of middleware, the other pieces of middleware are typically looking at the incoming request and making some decision about that request.
-The UseDeveloperExceptionPage doesn't care so much about the incoming requests as it does what happens later in the pipeline.
-It is going to just call into the next piece of middleware, but then it is going to wait to see if anything later in the pipeline generates an exception and if there is an exception, this piece of middleware will give you an error page with some additional information about that exception.


5. Static files
==============
=> Static files like JavaScript files, images, CSS files that we have on the file system are the assets that ASP.NET Core application can serve directly to clients.
Static files are typically located in the web root (wwwroot) folder.
By default, that is the only place where we can serve up files directly from the file system.

-Microsoft.AspNet.StaticFiles which will find the static files middleware. 
Let us install this nuget package and now we should have additional methods that we can use to register middleware inside the Configure method.

UseStaticFiles middle in Configure method as shown in the following program:

 public void Configure(IApplicationBuilder app) { 
         app.UseIISPlatformHandler();  
         app.UseDeveloperExceptionPage(); 
         app.UseRuntimeInfoPage(); 
         app.UseStaticFiles(); 
         
         app.Run(async (context) => { 
            throw new System.Exception("Throw Exception"); 
            var msg = Configuration["message"]; 
            await context.Response.WriteAsync(msg); 
         }); 
      }  

-You can always give IIS a list of default files to look for. If someone came to the root of a directory or, in this case, the root of the website and if IIS found something named index.html, it would just automatically serve that file.
Let us now start by making a few changes. First, we need to remove the forced error and then add another piece of middleware, which is UseDefaultFiles. 
The following is the implementation of the Configure method:

public void Configure(IApplicationBuilder app)  { 
   app.UseIISPlatformHandler();  
   app.UseDeveloperExceptionPage(); 
   
   app.UseRuntimeInfoPage();  
   app.UseDefaultFiles(); 
   app.UseStaticFiles();  
   
   app.Run(async (context) => { 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   });  
}

-If you are going to use UseDefaultFiles and UseStaticFiles, you might also want another piece of middleware that is inside the Microsoft.aspnet.staticfiles, NuGet package, and that is the FileServer middleware. 
This essentially includes the Default Files and the Static Files in the correct order.

public void Configure(IApplicationBuilder app) { 
   app.UseIISPlatformHandler();  
   app.UseDeveloperExceptionPage(); 
   
   app.UseRuntimeInfoPage();  
   app.UseFileServer();  
   
   app.Run(async (context) => { 
      var msg = Configuration["message"]; 
      await context.Response.WriteAsync(msg); 
   }); 
}


6. Setup MVC framework in ASP.NET Core
========================================
=> To setup MVC framework in our empty project, follow these steps −

Install the Microsoft.AspNet.Mvc package, which gives us access to the assemblies and classes provided by the framework.

Once the package is installed, we need to register all of the services that ASP.NET MVC requires at runtime. We will do this inside the ConfigureServices method.

Finally, we need to add middleware for ASP.NET MVC to receive requests. Essentially this piece of middleware takes an HTTP request and tries to direct that request to a C# class that we will write.

-Adding HomeController.cs in our project:
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppdemo.Controllers { 
   public class HomeController { 
      public string Index() { 
         return "Hello, World! this message is from Home Controller..."; 
      } 
   } 
}

-In addition to adding the NuGet package and the middleware, we also need to add the AddMvc service in the ConfigureServices.
 Here is the complete implementation of the Startup class:-

using Microsoft.AspNet.Builder; 
using Microsoft.AspNet.Hosting; 
using Microsoft.AspNet.Http; 

using Microsoft.Extensions.DependencyInjection; 
using Microsoft.Extensions.Configuration;  

namespace FirstAppDemo { 
   public class Startup { 
      public Startup() { 
         var builder = new ConfigurationBuilder() .AddJsonFile("AppSettings.json"); 
         Configuration = builder.Build(); 
      }  
      public IConfiguration Configuration { get; set; }
      
      // This method gets called by the runtime. 
      // Use this method to add services to the container. 
      // For more information on how to configure your application, 
      // visit http://go.microsoft.com/fwlink/?LinkID=398940 
      public void ConfigureServices(IServiceCollection services) { 
         services.AddMvc(); 
      }
      
      // This method gets called by the runtime.  
      // Use this method to configure the HTTP request pipeline. 
      public void Configure(IApplicationBuilder app) { 
         app.UseIISPlatformHandler();  
         
         app.UseDeveloperExceptionPage(); 
         app.UseRuntimeInfoPage();  
         
         app.UseFileServer(); 
         app.UseMvcWithDefaultRoute();  
         
         app.Run(async (context) => { 
            var msg = Configuration["message"]; 
            await context.Response.WriteAsync(msg); 
         });
      } 
      
      // Entry point for the application. 
      public static void Main(string[] args) => WebApplication.Run<Startup>(args); 
   }  
}
   
-Save the Startup.cs file and go to the browser and refresh it. You will now receive a response from our home controller


7. Routing
============
=> Routing is the process of directing an HTTP request to a controller.
-The ASP.NET Core middleware needs a way to determine if a given HTTP request should go to a controller for processing or not.

The MVC middleware will make this decision based on the URL and some configuration information we provide. 
In this chapter, we will define this configuration information or you can say routing information inside Startup.cs when we add the MVC middleware.

This approach is often referred to as the convention-based routing. 
The following is a code snippet for conventional routing.

                    routeBuilder.MapRoute("Default", "{controller=Home}/{action=Index}/{id?}");

In this approach, we define templates that tell MVC how to look at a URL and find a controller name and an action name where a controller is a C# class and an action is a public method on that class.

-Instead of using the UseMvcWithDefaultRoute, let us use the UseMvc, and then configure the route at this point using a named method ConfigureRoute. 
The following is the implementation of the Startup.cs file:-

using Microsoft.AspNet.Builder; 
using Microsoft.AspNet.Hosting; 
using Microsoft.AspNet.Http; 

using Microsoft.Extensions.DependencyInjection; 
using Microsoft.Extensions.Configuration; 
using Microsoft.AspNet.Routing; 
using System;  

namespace FirstAppDemo { 
   public class Startup { 
      public Startup() { 
         var builder = new ConfigurationBuilder() .AddJsonFile("AppSettings.json"); 
         Configuration = builder.Build(); 
      }  
      public IConfiguration Configuration { get; set; } 
      
      // This method gets called by the runtime. 
      // Use this method to add services to the container. 
      // For more information on how to configure your application, 
      // visit http://go.microsoft.com/fwlink/?LinkID=398940 
      public void ConfigureServices(IServiceCollection services) { 
         services.AddMvc(); 
      }  
        
      // This method gets called by the runtime.  
      // Use this method to configure the HTTP request pipeline. 
      public void Configure(IApplicationBuilder app) { 
         app.UseIISPlatformHandler();  
         
         app.UseDeveloperExceptionPage(); 
         app.UseRuntimeInfoPage();  
         
         app.UseFileServer(); 
         app.UseMvc(ConfigureRoute);  
         
         app.Run(async (context) => { 
            var msg = Configuration["message"]; 
            await context.Response.WriteAsync(msg); 
         });
      }  
      private void ConfigureRoute(IRouteBuilder routeBuilder) { 
         //Home/Index 
         routeBuilder.MapRoute("Default", "{controller = Home}/{action = Index}/{id?}");
      }  
        
      // Entry point for the application. 
      public static void Main(string[] args) => WebApplication.Run<Startup>(args);
   } 
}

-Inside the ConfigureRoute method, you can configure your routes; you can see that this method has to take a parameter of type IRouteBuilder. 
The goal of routing is to describe the rules that ASP.NET Core MVC will use to process an HTTP request and find a controller that can respond to that request.

-You can have one route that can map requests to different controllers.

-We can tell the routeBuilder that we want to map a new route and its name is “Default” and then provide the most important piece of routing information, which is the template.

-The template is a string, and it is going to describe to ASP.NET Core MVC how to pull apart a URL.

-In the last example, we have added a HomeController, so you can also request any of the following URLs, and they will be directed to the Index action on the HomeController as well.

		http://localhost:49940
               	 	http://localhost:49940/Home
 		http://localhost:49940/Home/Index
-When a browser requests http://mysite/or http://mysite/Home, it gets back the output from the HomeController’s Index method.

-You can try this as well by changing the URL in the browser. In this example, it is http://localhost:49940/, except that the port which might be different.

-If you append /Home or /Home/Index to the URL and press the Enter button, you will see the same result.

==>Let us create another controller by adding another class and call it AboutController.
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppDemo.Controllers  { 
   public class AboutController { 
      public string Phone() { 
         return "+49-333-3333333"; 
      }  
      public string Country() { 
         return "Germany"; 
      } 
   } 
} 

-If you go to /about, it is again going to fall through the middleware and go to your app.Run middleware and you will see the page with output:
Here, the ASP.NET Core MVC goes to the AboutController, but does not find an action specified. 
So it will default to Index and this controller doesn't have an Index method and then the request will go the next piece of middleware.


8. Attribute Routes
===================
=> With attribute-based routing, we can use C# attributes on our controller classes and on the methods internally in these classes. 
These attributes have metadata that tell ASP.NET Core when to call a specific controller.

-It is an alternative to convention-based routing.

-Routes are evaluated in the order that they appear, the order that you register them in, but it's quite common to map multiple routes particularly if you want to have different parameters in the URL or if you want to have different literals in the URL.

-What we want here is that when we specify /about, the application should invoke the Phone action of the AboutController. 
Here, we can enforce some explicit routes for this controller using a Route attribute. This attribute is in the namespace Microsoft.AspNet.Mvc.
The following is the implementation of AboutController in which the attribute routes are added:-

using Microsoft.AspNet.Mvc;  

using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppDemo.Controllers { 
   [Route("about")] 
   public class AboutController { 
      [Route ("")] 
      public string Phone() { 
         return "+49-333-3333333"; 
      }  
      [Route("country")] 
      public string Country() { 
         return "Germany"; 
      } 
   } 
}


9. Action Results
=================
=> Actions basically return different types of Action Results. The ActionResult class is the base for all the action results. 
The following is a list of different kind of action results and their behavior.

		Name	                	Behavior
	=======================================================
		ContentResult		Returns a string
		FileContentResult		Returns file content
		FilePathResult		Returns file content
		FileStreamResult		Returns file content.
		EmptyResult		Returns nothing
		JavaScriptResult		Returns script for execution
		JsonResult		Returns JSON formatted data
		RedirectToResult		Redirects to the specified URL
		HttpUnauthorizedResult	Returns 403 HTTP Status code
		RedirectToRouteResult	Redirect to different action/ different controller action
		ViewResult		Received as a response for view engine
		PartialViewResult		Received as a response for view engine

Example 1
Let us perform a simple example by opening the HomeController class and derive it from the controller based class. This base class is in the Microsoft.AspNet.Mvc namespace. 
The following is the implementation of the HomeController class.

using Microsoft.AspNet.Mvc; 
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppdemo.Controllers  { 
   public class HomeController : Controller { 
      public ContentResult Index() { 
         return Content("Hello, World! this message is from 
            Home Controller using the Action Result"); 
      } 
   } 
}

In the Index method, we have passed a string into the Content method. This Content method produces a ContentResult; this means the Index method will now return ContentResult.

Example 2
Let us take another example. Create a new folder in the project and call it Models. Inside the Models folder, we want to add a class that can represent an Employee.
Enter Employee.cs in the Name field. 
Here, the implementation of the Employee class contains two properties:-

using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppDemo.Models { 
   public class Employee { 
      public int ID { get; set; } 
      public string Name { get; set} 
   } 
}

Inside the Index action method of HomeController, we want to return an Employee object. 
The following is the implementation of HomeController:-

using FirstAppDemo.Models; 
using Microsoft.AspNet.Mvc; 

using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks;  

namespace FirstAppdemo.Controllers { 
   public class HomeController : Controller { 
      public ObjectResult Index() { 
         var employee = new Employee { ID = 1, Name = "Mark Upston"}; 
         return new ObjectResult(employee);                                                                                                                     // output in browser {"ID":1, "Name":"Mark Upston"}
      } 
   } 
}

Now, instead of returning the Content, we will return a different type of result which is known as ObjectResult. 
If we want an ObjectResult, we need to create or instantiate an ObjectResult and pass into it some model object.

-An ObjectResult is special in the MVC framework because when we return an ObjectResult, the MVC framework looks at this object. 
This object needs to be represented in the HTTP response.

-This object should be serialized into XML or JSON or some other format and ultimately, the decision will be made based on the configuration information that you give to the MVC at startup. 
If you don't configure anything, you just get some defaults, and the default is a JSON response.


